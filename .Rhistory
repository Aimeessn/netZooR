levels(factor(esub[,1]))
levels(factor(esub[,2]))
T0
T0 <- data.frame(as.integer(factor(blue.names)),1:4)
blue.names <- levels(factor(esub[,2]))
blue.names
T0 <- data.frame(as.integer(factor(blue.names)),1:4)
T0
condor.modularity.max(condor.object)
condor.modularity.max(condor.object,T0=T0)
T0 <- data.frame(blue.names,1:4)
condor.modularity.max(condor.object,T0=T0)
typeof(blue.names)
levels(blue.names)
T0
typeof(T0)
data.frame(nodes=blues,coms=1:4)
T0 = data.frame(nodes=blues,coms=1:4)
condor.modularity.max(condor.object,T0=T0)
condor.modularity.max(condor.object,T0=T0[c(1,3,4,2),])
elist <- condor.object$edges
G <- graph.data.frame(elist,directed=FALSE)
reds = as.integer(factor(elist[,1]))
red.names = levels(factor(elist[,1]))
#Gene column indices
blues = as.integer(factor(elist[,2]))
blue.names = levels(factor(elist[,2]))
N = max(blues)
sM = sparseMatrix(i=reds,j=blues,x=1,dims=c(length(unique(reds)),length(unique(blues))),index1=T);
gM = t(sM) %*% sM;
colnames(gM) <- blue.names
rownames(gM) <- blue.names
G1 = graph.adjacency(gM,mode="undirected",weight=TRUE,diag=FALSE);
gcc.initialize = simplify(max.component(G1))
gcc.initialize
multilevel.community(gcc.initialize)
names(gcc.initialize)
E(gcc.initialize)
E(gcc.initialize)$weights
E(gcc.initialize)$weight
fastgreedy.community(gcc.initialize)
T0 <- data.frame(nodes=blues,coms=1)
T0
condor.object
dt1 <- data.table(condor.object$edges)
dt1
names(dt1)
condor.object$red.memb
dt.red <- condor.object$red.memb
dt.red <- data.table(condor.object$red.memb)
dt.red
set.names(dt.red,"red.names","red")
setnames(dt.red,"red.names","red")
dt.red
dt3 <- merge(dt1,dt.red,by="red.names",all.x=TRUE)
dt3 <- merge(dt1,dt.red,by="red",all.x=TRUE)
dt3
setnames(dt.red,"com","red.com")
dt3 <- merge(dt1,dt.red,by="red",all.x=TRUE)
dt3
dt.blue <- data.table(condor.object$blue.memb)
setnames(dt.blue,c("blue","blue.com"))
dt.blue
dt4 <- merge(dt3,dt.blue,by="blue",all.x=TRUE)
dt4
load("~/Desktop/Desktop stuff/PANDA_BRIM_Output_COAD.rData")
names(BrimOut)
ls()
DATA
data
names(BrimOut)
head(BrimOut)
head(BrimOut$red.memb)
head(BrimOut$blue.memb)
condor.object
head(BrimOut$red.memb)
a1 <- sample(brim.out$red.memb[,1],10)
a1 <- sample(BRIM.out$red.memb[,1],10)
a1 <- sample(BrimOut$red.memb[,1],10)
a1
b1 <- sample(BrimOut$blue.memb[,1],10)
edges <- data.frame(red=a1,blue=b1)
edges
brim_object <- BrimOut
dt0 <- data.table(edges)
setnames(dt0,c("SNP","gene"))
dt1 <- data.table(brim_object$red.memb)
setnames(dt1,c("SNP","red.memb"))
dt2 <- data.table(brim_object$blue.memb)
setnames(dt2,c("gene","blue.memb"))
dt3 <- merge(dt0,dt1,by="SNP",all.x=TRUE)
eqtl_object <- merge(dt3,dt2,by="gene",all.x=TRUE)
eqtl_object
BrimOut$red.memb[BrimOut$red.memb[,1]=="COL8A2",]
BrimOut$blue.memb[BrimOut$blue.memb[,1]=="TCGA-CK-5916-01A-11D-1650-10",]
make.community.blocks = function(edges,brim_object,color_list,figure_out="Community_structure_matrix_FDR10",point.size=0.01){
#' @param edges a two column data.frame representing the edgelist.
#' The first column should contain the red nodes (the genes) and the second
#' column should contain the blue nodes (the patients)
#' @param brim_object the output of \code{\link{BRIM}} or
#' \code{\link{fast.brim}}
#'  @param color_list a vector of hex codes for the colors, one color per
#'  community.
#'  @param figure_out filename for output plot.
dt0 <- data.table(edges)
setnames(dt0,c("SNP","gene"))
dt1 <- data.table(brim_object$red.memb)
setnames(dt1,c("SNP","red.memb"))
dt2 <- data.table(brim_object$blue.memb)
setnames(dt2,c("gene","blue.memb"))
dt3 <- merge(dt0,dt1,by="SNP",all.x=TRUE)
eqtl_object <- merge(dt3,dt2,by="gene",all.x=TRUE)
setkey(eqtl_object,"SNP")
eqtl_all <- data.table(eqtl_object[!is.na(SNP)])
#this groups red and blue nodes in the same community. very important
eqtl_block <- eqtl_all[blue.memb==red.memb]
#setkeyv(eqtl1,c("SNP","blue.memb","gene","red.memb"))
if(nlevels(eqtl_block$SNP) != length(unique(eqtl_block$SNP))){
print("warning: empty levels in SNP column. This may cause silent issues with plotting.")}
#select all links that connect nodes in the same community
setkey(eqtl_block,"blue.memb","red.memb")
#make new index for each node that will correspond to it's row/col number
red_tmp <- data.table(rindx=1:nlevels(eqtl_block$SNP),SNP=unique(eqtl_block$SNP))
red_indx <- merge(red_tmp,unique(eqtl_block,by="SNP")[,c("SNP","red.memb"),with=FALSE],by="SNP")
red_indx[,red.com.size:=length(unique(SNP)),by=red.memb]
red_indx[red.com.size > 1,rindx:=sample(x=rindx),by=red.memb][,red.memb:=NULL,]
setkey(red_indx,"SNP")
blue_tmp <- data.table(bindx=1:nlevels(eqtl_block$gene),gene=unique(eqtl_block$gene))
blue_indx <- merge(blue_tmp,unique(eqtl_block,by="gene")[,c("gene","blue.memb"),with=FALSE],by="gene")
#shuffle nodes within each community to make density homogeneous
blue_indx[,blue.com.size:=length(unique(gene)),by=blue.memb]
blue_indx[blue.com.size > 1,bindx:=sample(x=bindx),by=blue.memb][,blue.memb:=NULL,]
setkey(blue_indx,"gene")
if(dim(red_indx)[1] != nlevels(eqtl_all$SNP) && dim(blue_indx)[1] != nlevels(eqtl_all$gene)){
print("Warning! not all nodes in block!")
}
#in the unlikely event a node is only connected to nodes in OTHER comms
#if(nlevels(eqtl_all$SNP) != nlevels(eqtl_all$SNP)){
#  tmp = setdiff(levels(eqtl_all$SNP),levels(eqtl_all$SNP))
m1 <- merge(eqtl_all,red_indx,by="SNP",all=TRUE)
#setkey(m1,"gene")
m2 <- merge(m1,blue_indx,by="gene",all=TRUE)
#pdf("Community_structure_matrix.pdf",height=7,width=12)
setEPS()
postscript(paste0(figure_out,".eps"),height=7,width=15)#,width=720,height=480,res=300,pointsize=3)
par(mar=c(3,3,3,0.5)+0.1)
#plot links that connect nodes in different communities
m2[red.memb != blue.memb][plot(rindx,bindx,cex=point.size,xaxt="n",yaxt="n",
xaxs="i",yaxs="i",ylim=c(0,max(m2$bindx)+1),
xlim=c(0,max(m2$rindx)+1),xlab="",ylab="",pch=19)]
#plot links that connect nodes in same communities
m2[red.memb==blue.memb][points(rindx,bindx,cex=point.size,pch=19,
col=color_list[red.memb])]
box(lwd=2)
mtext("SNPs",side=3,font=2,cex=2.5,padj=-0.25)
mtext("Genes",side=2,font=2,cex=2.5,padj=-0.5)
## Add community labels to top
cs <- cumsum(rle(sort(m2[!duplicated(SNP)]$red.memb))$lengths)
lens <- rle(sort(m2[!duplicated(SNP)]$red.memb))$lengths
lpts <- cs - lens/2
axis(1,at=lpts,labels=1:length(color_list),lwd.ticks=-0.1,cex.axis=1.25,padj=0.25,font=2)
dev.off()
}
make.community.blocks(edges=edges,brim_object=brim_object)
edges
eqtl_object
setkey(eqtl_object,"SNP")
eqtl_all <- data.table(eqtl_object[!is.na(SNP)])
eqtl_block <- eqtl_all[blue.memb==red.memb]
if(nlevels(eqtl_block$SNP) != length(unique(eqtl_block$SNP))){
print("warning: empty levels in SNP column. This may cause silent issues with plotting.")}
#select all links that connect nodes in the same community
setkey(eqtl_block,"blue.memb","red.memb")
#make new index for each node that will correspond to it's row/col number
red_tmp <- data.table(rindx=1:nlevels(eqtl_block$SNP),SNP=unique(eqtl_block$SNP))
red_indx <- merge(red_tmp,unique(eqtl_block,by="SNP")[,c("SNP","red.memb"),with=FALSE],by="SNP")
red_indx[,red.com.size:=length(unique(SNP)),by=red.memb]
red_indx[red.com.size > 1,rindx:=sample(x=rindx),by=red.memb][,red.memb:=NULL,]
setkey(red_indx,"SNP")
blue_tmp <- data.table(bindx=1:nlevels(eqtl_block$gene),gene=unique(eqtl_block$gene))
blue_indx <- merge(blue_tmp,unique(eqtl_block,by="gene")[,c("gene","blue.memb"),with=FALSE],by="gene")
#shuffle nodes within each community to make density homogeneous
blue_indx[,blue.com.size:=length(unique(gene)),by=blue.memb]
blue_indx[blue.com.size > 1,bindx:=sample(x=bindx),by=blue.memb][,blue.memb:=NULL,]
setkey(blue_indx,"gene")
if(dim(red_indx)[1] != nlevels(eqtl_all$SNP) && dim(blue_indx)[1] != nlevels(eqtl_all$gene)){
print("Warning! not all nodes in block!")
}
m1 <- merge(eqtl_all,red_indx,by="SNP",all=TRUE)
eqtl_all
red_indx
nlevels(eqtl_block$SNP)
nlevels(eqtl_object$SNP)
nlevels(eqtl_object$SNP) <- nlevels(edges[,1])
levels(eqtl_object$SNP) <- levels(edges[,1])
nlevels(eqtl_object$SNP)
levels(edges)
?nlevels
levels(eqtl_object$SNP) <- unique(edges[,1])
levels(eqtl_object$SNP)
levels(eqtl_object$SNP) <- NULL
?droplevels
droplevels(eqtl_object$SNP)
levels(eqtl_object$SNP)
eqtl0 <- eqtl_object
eqtl0$SNP
eqtl0$SNP <- factor(eqtl0$SNP)
eqtl0$SNP
eqtl0$SNP <- droplevels(eqtl_object$SNP)
eqtl0$SNP
dt0 <- data.table(edges)
setnames(dt0,c("SNP","gene"))
dt1 <- data.table(brim_object$red.memb)
setnames(dt1,c("SNP","red.memb"))
dt2 <- data.table(brim_object$blue.memb)
setnames(dt2,c("gene","blue.memb"))
dt3 <- merge(dt0,dt1,by="SNP",all.x=TRUE)
eqtl_object <- merge(dt3,dt2,by="gene",all.x=TRUE)
setkey(eqtl_object,"SNP")
eqtl_all <- data.table(eqtl_object[!is.na(SNP)])
eqtl_all$SNP <- droplevels(eqtl_all$SNP)
eqtl_all$gene <- droplevels(eqtl_all$SNP)
#this groups red and blue nodes in the same community. very important
eqtl_block <- eqtl_all[blue.memb==red.memb]
level(eqtl_block$SNP)
levels(eqtl_block$SNP)
levels(eqtl_block$gene)
eqtl_all$gene <- droplevels(eqtl_all$gene)
eqtl_all <- data.table(eqtl_object[!is.na(SNP)])
eqtl_all$SNP <- droplevels(eqtl_all$SNP)
eqtl_all$gene <- droplevels(eqtl_all$gene)
#this groups red and blue nodes in the same community. very important
eqtl_block <- eqtl_all[blue.memb==red.memb]
levels(eqtl_block$gene)
if(nlevels(eqtl_block$SNP) != length(unique(eqtl_block$SNP))){
print("warning: empty levels in SNP column. This may cause silent issues with plotting.")}
#select all links that connect nodes in the same community
setkey(eqtl_block,"blue.memb","red.memb")
#make new index for each node that will correspond to it's row/col number
red_tmp <- data.table(rindx=1:nlevels(eqtl_block$SNP),SNP=unique(eqtl_block$SNP))
red_indx <- merge(red_tmp,unique(eqtl_block,by="SNP")[,c("SNP","red.memb"),with=FALSE],by="SNP")
red_indx[,red.com.size:=length(unique(SNP)),by=red.memb]
red_indx[red.com.size > 1,rindx:=sample(x=rindx),by=red.memb][,red.memb:=NULL,]
setkey(red_indx,"SNP")
blue_tmp <- data.table(bindx=1:nlevels(eqtl_block$gene),gene=unique(eqtl_block$gene))
blue_indx <- merge(blue_tmp,unique(eqtl_block,by="gene")[,c("gene","blue.memb"),with=FALSE],by="gene")
#shuffle nodes within each community to make density homogeneous
blue_indx[,blue.com.size:=length(unique(gene)),by=blue.memb]
blue_indx[blue.com.size > 1,bindx:=sample(x=bindx),by=blue.memb][,blue.memb:=NULL,]
setkey(blue_indx,"gene")
if(dim(red_indx)[1] != nlevels(eqtl_all$SNP) && dim(blue_indx)[1] != nlevels(eqtl_all$gene)){
print("Warning! not all nodes in block!")
}
#in the unlikely event a node is only connected to nodes in OTHER comms
#if(nlevels(eqtl_all$SNP) != nlevels(eqtl_all$SNP)){
#  tmp = setdiff(levels(eqtl_all$SNP),levels(eqtl_all$SNP))
m1 <- merge(eqtl_all,red_indx,by="SNP",all=TRUE)
#setkey(m1,"gene")
m2 <- merge(m1,blue_indx,by="gene",all=TRUE)
eqtl_all
eqtl_all
red.indx
red_indx
eqtl_block
condor.object
brim.object <- condor.object
edges <- brim.object$edges
brim_object <- condor.object
dt0 <- data.table(edges)
setnames(dt0,c("SNP","gene"))
dt1 <- data.table(brim_object$red.memb)
setnames(dt1,c("SNP","red.memb"))
dt2 <- data.table(brim_object$blue.memb)
setnames(dt2,c("gene","blue.memb"))
dt3 <- merge(dt0,dt1,by="SNP",all.x=TRUE)
eqtl_object <- merge(dt3,dt2,by="gene",all.x=TRUE)
setkey(eqtl_object,"SNP")
eqtl_all <- data.table(eqtl_object[!is.na(SNP)])
eqtl_all$SNP <- droplevels(eqtl_all$SNP)
eqtl_all$gene <- droplevels(eqtl_all$gene)
#this groups red and blue nodes in the same community. very important
eqtl_block <- eqtl_all[blue.memb==red.memb]
if(nlevels(eqtl_block$SNP) != length(unique(eqtl_block$SNP))){
print("warning: empty levels in SNP column. This may cause silent issues with plotting.")}
#select all links that connect nodes in the same community
setkey(eqtl_block,"blue.memb","red.memb")
#make new index for each node that will correspond to it's row/col number
red_tmp <- data.table(rindx=1:nlevels(eqtl_block$SNP),SNP=unique(eqtl_block$SNP))
red_indx <- merge(red_tmp,unique(eqtl_block,by="SNP")[,c("SNP","red.memb"),with=FALSE],by="SNP")
red_indx[,red.com.size:=length(unique(SNP)),by=red.memb]
red_indx[red.com.size > 1,rindx:=sample(x=rindx),by=red.memb][,red.memb:=NULL,]
setkey(red_indx,"SNP")
blue_tmp <- data.table(bindx=1:nlevels(eqtl_block$gene),gene=unique(eqtl_block$gene))
blue_indx <- merge(blue_tmp,unique(eqtl_block,by="gene")[,c("gene","blue.memb"),with=FALSE],by="gene")
#shuffle nodes within each community to make density homogeneous
blue_indx[,blue.com.size:=length(unique(gene)),by=blue.memb]
blue_indx[blue.com.size > 1,bindx:=sample(x=bindx),by=blue.memb][,blue.memb:=NULL,]
setkey(blue_indx,"gene")
if(dim(red_indx)[1] != nlevels(eqtl_all$SNP) && dim(blue_indx)[1] != nlevels(eqtl_all$gene)){
print("Warning! not all nodes in block!")
}
#in the unlikely event a node is only connected to nodes in OTHER comms
#if(nlevels(eqtl_all$SNP) != nlevels(eqtl_all$SNP)){
#  tmp = setdiff(levels(eqtl_all$SNP),levels(eqtl_all$SNP))
m1 <- merge(eqtl_all,red_indx,by="SNP",all=TRUE)
#setkey(m1,"gene")
m2 <- merge(m1,blue_indx,by="gene",all=TRUE)
par(mar=c(3,3,3,0.5)+0.1)
#plot links that connect nodes in different communities
m2[red.memb != blue.memb][plot(rindx,bindx,cex=point.size,xaxt="n",yaxt="n",
xaxs="i",yaxs="i",ylim=c(0,max(m2$bindx)+1),
xlim=c(0,max(m2$rindx)+1),xlab="",ylab="",pch=19)]
#plot links that connect nodes in same communities
m2[red.memb==blue.memb][points(rindx,bindx,cex=point.size,pch=19,
col=color_list[red.memb])]
box(lwd=2)
mtext("SNPs",side=3,font=2,cex=2.5,padj=-0.25)
mtext("Genes",side=2,font=2,cex=2.5,padj=-0.5)
## Add community labels to top
cs <- cumsum(rle(sort(m2[!duplicated(SNP)]$red.memb))$lengths)
lens <- rle(sort(m2[!duplicated(SNP)]$red.memb))$lengths
lpts <- cs - lens/2
axis(1,at=lpts,labels=1:length(color_list),lwd.ticks=-0.1,cex.axis=1.25,padj=0.25,font=2)
color_list = c("darkgreen","darkorange")
par(mar=c(3,3,3,0.5)+0.1)
#plot links that connect nodes in different communities
m2[red.memb != blue.memb][plot(rindx,bindx,cex=point.size,xaxt="n",yaxt="n",
xaxs="i",yaxs="i",ylim=c(0,max(m2$bindx)+1),
xlim=c(0,max(m2$rindx)+1),xlab="",ylab="",pch=19)]
#plot links that connect nodes in same communities
m2[red.memb==blue.memb][points(rindx,bindx,cex=point.size,pch=19,
col=color_list[red.memb])]
box(lwd=2)
mtext("SNPs",side=3,font=2,cex=2.5,padj=-0.25)
mtext("Genes",side=2,font=2,cex=2.5,padj=-0.5)
## Add community labels to top
cs <- cumsum(rle(sort(m2[!duplicated(SNP)]$red.memb))$lengths)
lens <- rle(sort(m2[!duplicated(SNP)]$red.memb))$lengths
lpts <- cs - lens/2
axis(1,at=lpts,labels=1:length(color_list),lwd.ticks=-0.1,cex.axis=1.25,padj=0.25,font=2)
point.size=1
par(mar=c(3,3,3,0.5)+0.1)
#plot links that connect nodes in different communities
m2[red.memb != blue.memb][plot(rindx,bindx,cex=point.size,xaxt="n",yaxt="n",
xaxs="i",yaxs="i",ylim=c(0,max(m2$bindx)+1),
xlim=c(0,max(m2$rindx)+1),xlab="",ylab="",pch=19)]
#plot links that connect nodes in same communities
m2[red.memb==blue.memb][points(rindx,bindx,cex=point.size,pch=19,
col=color_list[red.memb])]
box(lwd=2)
mtext("SNPs",side=3,font=2,cex=2.5,padj=-0.25)
mtext("Genes",side=2,font=2,cex=2.5,padj=-0.5)
## Add community labels to top
cs <- cumsum(rle(sort(m2[!duplicated(SNP)]$red.memb))$lengths)
lens <- rle(sort(m2[!duplicated(SNP)]$red.memb))$lengths
lpts <- cs - lens/2
axis(1,at=lpts,labels=1:length(color_list),lwd.ticks=-0.1,cex.axis=1.25,padj=0.25,font=2)
condor.object$edges
condor.object
reds <- paste0("red",1:20)
blues <- paste0("blue",1:20)
blues
rstub <- sample(reds,100,replace=TRUE)
bstub <- sample(blues,100,replace=TRUE)
elist0 <- cbind(rstub,bstub)
head(elist0)
library(igraph)
g0 <- graph.data.frame(elist0)
clusters(g0)
length(unique(rstub))
length(unique(bstub))
write.table(elist0,file="~/Desktop/toy_bipartite39nodes.txt",header=FALSE,quote=FALSE,row.names=FALSE)
write.table(elist0,file="~/Desktop/toy_bipartite39nodes.txt",colnames=FALSE,quote=FALSE,row.names=FALSE)
write.table(elist0,file="~/Desktop/toy_bipartite39nodes.txt",col.names=FALSE,quote=FALSE,row.names=FALSE)
?plot
data.frame(node=unique(elist0[,1]),type=1)
node.att <- data.frame(node=unique(elist0[,1]),type=1)
write.table(node.att,file="~/Desktop/toy_bipartite39nodes_attributes.txt",col.names=FALSE,quote=FALSE,row.names=FALSE)
source('~/Dropbox/brimdev/CONDOR0.99.2/condor.plot.communities.R', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
condor.plot.communities(condor.object,color_list,point.size=2)
condor.plot.communities(condor.object,color_list,point.size=2,xlab="Guys",ylab="Gals")
condor.object
condor.plot.communities(condor.object,color_list,point.size=2,xlab="Gals",ylab="Guys")
condor.plot.communities(condor.object,color_list,point.size=2,xlab="Gals",ylab="Guys")
condor.plot.communities(condor.object,color_list,point.size=2,xlab="Gals",ylab="Guys")
condor.plot.communities(condor.object,color_list,point.size=2,xlab="Gals",ylab="Guys")
condor.plot.communities(condor.object,color_list,point.size=2,xlab="Gals",ylab="Guys")
condor.plot.communities(condor.object,color_list,point.size=2,xlab="Gals",ylab="Guys")
condor.plot.communities(condor.object,color_list,point.size=2,xlab="Gals",ylab="Guys")
condor.plot.communities(condor.object,color_list,point.size=2,xlab="Gals",ylab="Guys")
condor.plot.communities(condor.object,color_list,point.size=2,xlab="Gals",ylab="Guys")
condor.plot.communities(condor.object,color_list,point.size=2,xlab="Gals",ylab="Guys")
condor.object
source('~/Dropbox/brimdev/CONDOR0.99.2/condor.qscore.R', echo=TRUE)
condor.object <- condor.qscore(condor.object)
condor.object
condor.object$qscores$red.qscore
source('~/Dropbox/brimdev/CONDOR0.99.2/condor.core.enrich.R', echo=TRUE)
q_in_women <- condor.object$qscores$red.qscore
qstats_women <- condor.core.enrich(c("Alice","Mary"),q=q_in,plot.hist=TRUE)
qstats_women <- condor.core.enrich(c("Alice","Mary"),q=q_in_women,plot.hist=TRUE)
qstats_women
qstats_women <- condor.core.enrich(c("Alice","Mary"),q=q_in_women,plot.hist=TRUE,perm=TRUE)
source('~/Dropbox/brimdev/CONDOR0.99.2/condor.core.enrich.R', echo=TRUE)
source('~/Dropbox/brimdev/CONDOR0.99.2/condor.core.enrich.R', echo=TRUE)
qstats_women <- condor.core.enrich(c("Alice","Mary"),q=q_in_women,plot.hist=TRUE,perm=TRUE)
q_in_women
qstats_women <- condor.core.enrich("Mary",q=q_in_women,plot.hist=TRUE,perm=TRUE)
warnings()
qstats_women <- condor.core.enrich(c("Mary","Sue"),q=q_in_women,plot.hist=TRUE,perm=TRUE)
qstats_women <- condor.core.enrich(c("Mary","Sue"),q=q_in_women,plot.hist=TRUE,perm=TRUE)
qstats_women <- condor.core.enrich(c("Mary","Sue"),q=q_in_women,plot.hist=TRUE,perm=TRUE)
ks.test
?ks.test
document()
library(devtools)
document()
document()
document()
document()
system("ls")
?document
document()
document()
document(load_code=getwd())
?document
load_all()
document()
build()
check()
document()
check()
document()
load_all(0
0
load_all()
build()
document()
?roxygen
vignette("roxygen2", package = "roxygen2")
devtools::document()
roxygen2::roxygenise()
roxygen2::roxygenise(".")
?roxygen2::roxgenise
?roxygen2::roxygenise
roxygen2::roxygenise("./")
roxygen2::roxygenise("~/Dropbox/brimdev/CONDOR0.99.2/")
library(roxygen2)
document()
document()
run_examples()
q_in <- condor.object$qscores$red.qscore
q_in
condor.core.enrich(c("Alice","Mary"),q=q_in,perm=TRUE,plot.hist=TRUE)
run_examples()
r = c(1,1,1,2,2,2,3,3,3,4,4);
r = c(1,1,1,2,2,2,3,3,3,4,4);
r = c(1,1,1,2,2,2,3,3,3,4,4);
b = c(1,2,3,1,2,4,2,3,4,3,4);
reds <- c("Alice","Sue","Janine","Mary")
blues <- c("Bob","John","Ed","Hank")
elist <- data.frame(red=reds[r],blue=blues[b])
condor.object <- create.condor.object(elist)
condor.object <- condor.cluster(condor.object)
q_in <- condor.object$qscores$red.qscore
out <- condor.core.enrich(c("Alice","Mary"),q=q_in,perm=TRUE,plot.hist=TRUE)
q_in
condor.object
install()
install()
install()
document()
document()
test()
check()
library(data.table)
check()
check()
check()
check()
run_examples()
check_doc()
?Matrix
?MASS
check()
check()
library(MASS)
install.packages("MASS")
check()
q()
library(devtools)
install_local("../condor")
library(condor)
vignette("condor")
vignette(package="condor")
sum('a')
type('a')
class(mtcars)
class(mtcars$mpg)
class(mtcars$cyl)
View(iris)
class(iris$Species)
is.na(iris$weaf)
is.null(iris$weaf)
message
message("hello world")
?stopifnot
any.na
any(is.na(c(NA,1)))
devtools::document()
devtools::document()
