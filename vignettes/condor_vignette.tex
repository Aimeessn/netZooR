\documentclass{article}
%\VignetteIndexEntry{CONDOR Vignette}
%\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\title{CONDOR Vignette}
\author{John Platig}
\usepackage{Sweave}
\begin{document}
\input{condor_vignette-concordance}
\maketitle
%\SweaveOpts{concordance=TRUE}

\section{Introduction}
This package implements methods for clustering bipartite networks and estimating the contribution of each node to its community's modularity. For an application of this method to identify diesease-associated Single Nucleotide Polymorphisms, see \url{http://arxiv.org/abs/1509.02816}.

\section{Implementing the Bipartite Modularity Maximization}
The code in \textbf{condor.modularity.max} is an implementation of the method described in Michael Barber's paper \textbf{Modularity and community detection in bipartite networks} (Phys. Rev. E 76, 066102 (2007)). A few general comments:
\begin{itemize}
\item Maximizing bipartite modularity is an NP-hard problem
\item Method are heuristic and can depend on initial assignments of the nodes to communities
\item For the implementation in \textbf{condor.cluster}, I use a non-bipartite community detection method from the \textbf{igraph} package to use as initial assignments of nodes to communities, which are then used in \textbf{condor.modularity.max}.
\item Community structure is designed to cluster networks that form a giant connected component. All of the analysis in this package uses the giant connected component.
\end{itemize}
\section{Workflow}
\begin{Schunk}
\begin{Sinput}
> library(CONDOR)
> library(igraph)
\end{Sinput}
\end{Schunk}
\textbf{CONDOR} works with an edgelist (\textbf{elist} in the code below) as its input. 
\begin{Schunk}
\begin{Sinput}
> r = c(1,1,1,2,2,2,3,3,3,4,4);
> b = c(1,2,3,1,2,4,2,3,4,3,4);
> reds <- c("Alice","Sue","Janine","Mary")
> blues <- c("Bob","John","Ed","Hank")
> elist <- data.frame(red=reds[r],blue=blues[b])
\end{Sinput}
\end{Schunk}
In \textbf{elist}, notice all nodes of the same type--women and men in this case--appear in the same column together. This is a requirement. \textbf{create.condor.object} will throw an error if a node appears in both columns. 
\begin{Schunk}
\begin{Sinput}
> condor.object <- create.condor.object(elist)
\end{Sinput}
\end{Schunk}
A condor.object is just a list. You can look at the different items using \textbf{names}
\begin{Schunk}
\begin{Sinput}
> names(condor.object)
\end{Sinput}
\begin{Soutput}
[1] "G"          "edges"      "Qcom"       "modularity" "red.memb"  
[6] "blue.memb"  "qscores"   
\end{Soutput}
\end{Schunk}
\textbf{condor.cluster} will cluster the nodes and produce the overall modularity along with two community membership \textbf{data.frames}:
\begin{Schunk}
\begin{Sinput}
> condor.object <- condor.cluster(condor.object)
\end{Sinput}
\begin{Soutput}
[1] "modularity of projected graph 0"
[1] "making new comm"
[1] "Q = 0.140495867768595"
[1] "Q = 0.231404958677686"
[1] "Q = 0.231404958677686"
\end{Soutput}
\begin{Sinput}
> print(condor.object$red.memb)
\end{Sinput}
\begin{Soutput}
  red.names com
1     Alice   2
2    Janine   1
3      Mary   1
4       Sue   2
\end{Soutput}
\begin{Sinput}
> print(condor.object$blue.memb)
\end{Sinput}
\begin{Soutput}
  blue.names com
1        Bob   2
2         Ed   1
3       Hank   1
4       John   2
\end{Soutput}
\end{Schunk}
Nodes in first community are {Alice, John, Bob, Sue}, nodes in second community are {Ed, Janine, Hank, Mary} based on the modularity maximization. Here's a picture:

\begin{Schunk}
\begin{Sinput}
> gtoy = graph.edgelist(as.matrix(elist),directed=FALSE)
> set.graph.attribute(gtoy, "layout", layout.kamada.kawai(gtoy))
\end{Sinput}
\begin{Soutput}
IGRAPH UN-- 8 11 -- 
+ attr: layout (g/n), name (v/c)
\end{Soutput}
\begin{Sinput}
> V(gtoy)[c(reds,blues)]$color <- c(rep("red",4),rep("blue",4))
\end{Sinput}
\end{Schunk}

\begin{Schunk}
\begin{Sinput}
> plot(gtoy,vertex.label.dist=2)
\end{Sinput}
\end{Schunk}
\includegraphics{condor_vignette-007}

To get each node's modularity contribution (as a fraction of the community's modularity), run
\begin{Schunk}
\begin{Sinput}
> condor.object <- condor.qscore(condor.object)   
\end{Sinput}
\end{Schunk}
If you have a subset of nodes that you think are more likely to lie at the cores of your communities, you can test this using \textbf{condor.core.enrich}:

\begin{Schunk}
\begin{Sinput}
> q_women <- condor.object$qscores$red.qscore
> core_stats <- condor.core.enrich(test_nodes=c("Alice","Mary"),q=q_women,perm=TRUE,plot.hist=TRUE)
\end{Sinput}
\end{Schunk}
\includegraphics{condor_vignette-009}

If you have more questions, contact John Platig at \url{jplatig@jimmy.harvard.edu}

\end{document}
